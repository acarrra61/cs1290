IntegerBreak
As I was reading the example on this code problem, I realized that any input that is given let’s say 5, it has two possible solutions when you add them (which in this case it’s the product when you multiply them.) Also, right away I noticed I have to get the maximum product. When you add 1+4 you get 5 but when you multiply them you get 4, it goes the same with 2+3. But, when you multiply them you get 6, which is the maximum product. I will start off by talking about the code on what I used. On the sopl is where it represents the recursion call with any given value that is no less than 2 and not larger than 58. Then, the base case comes up with my linked list given the last element which is the product of the other elements. I use if-statements with the given value(n) if its less than or equal to 1 or if the value(n) is equal to 2(this is for n to be the right size). Next, is the for-loop where x+y = n (x is the first number, y is the 2nd number). The lists I made for x and y (xList,yList) has to be used with a recursion call for x and y getting the most product with its own method when I created it later, which is breaking the integer. Next, I used a resultList which I added the xList and yList and combined them to get the result with another method, which I used later being used (combineList). From here on out for every result in resultList. I compared results until I found the MaxList. Then, I returned it.



PerfectSquares
Starting off with a given positive integer, in this case n=12, this is where I print it out in the code. The base comes with a linkedlist, that is with the sumList (this is where it all begins) which finds the sum to n. from here I created a temp so that’s where n would go, which is also the recursion part for the perfect squares, getting the sum from the list. I created an iteration method called Sum. Its own Boolean method is PerfectSquare, to see if n is a perfect, and finally the explanation with its own method which I had to do a lot of debugging at times! But I got it done.



PalindromicSubstrings
First, I started off with a variable call of String s, which in this case I used “abc” like in the example. From here I was thinking to myself, let’s make a LinkedList of string called list which is equal to palindromicSubsting of (s) which I will get to later. But, first I am going to start right away with the explanation. Starting off with a for loop which is (i) is less than the list size, so I can get the palindromicSubstrings in this string. Now, this is where I find the substringLength and I created the substringList which is if (s) is a palindrome then I would add (s) to the substringList. Then, the for loop was added with the String substring if isPalindrome then I would add the substring (which here is my recursion call). Then I would return substringList. My next method is where the method is being called for the palindromicSubstrings. Lastly, this is where my Boolean method of palindrome is being used which I call it to see if it’s palindrome.



StoneGame
I changed the game so that whenever Lee scores points, it reduces from Alex’s score instead. I let dp(I,j) be the largest score which Alex can achieve which where the piles remaining are piles[I], piles[I+1],…,piles[j]. , I decided to make a recursion for dp(I,j) in terms of the dp(i+1,j) and dp(I,j-1) (dp stands for dynamic programming, which made sense to me for recursion) Since I needed to know what the value of each of the position of the game is . When the piles remaining are piles[i], piles[i+1],…,piles[j], the player who’s turn it is has the most two moves. The person who’s turn it was can be found by comparing j-1 to N. If the player is Alex, then she either takes the piles[i] or piles[j], increasing her score by that amount. After, the total score is either piles[i] + dp(i+1,j), or piles[j] + dp(I,j-1) and we want the Maximum possible score. If the player is Lee, then he either takes the piles[i] or piles[j] decreasing Alex’s score by that amount. Afterwords, the total score is either -piles[i] + dp(i+1,j), or -piles[j] + dp(I,j-1).  This is for the minimum possible score.



MinumumPathSum
To start off the input is a 2d grid and the output is going to be one integer and what I needed is to find the minimum path from the top from any of the columns to get to the bottom and pathFalling(int[][] grid). At this point I can go either straight down or left or right at the most 1 (this is imagining an input with numbers which would look like this:  output = 12, input: 1,2,3,4,5,6,7,8,9) so from 2 we can go to 6 or 5 or 4 from 3. I can go to 6 or 5 from 3 so I can to 6 or 5, since I can’t go out of bounds in this case. The way I solved this was to use a 2d grid of dp. I populated my 2d grid and then at the end I returned the minimum number in the last row of my dp array (this is also going to be my 2d grid). The first thing I did was go layer by layer because each of spot is a directed acyclic graph on it’s predecessor except for the base case unfortunately. It’s going to be just this row itself because that’s the minimum cost to get to the first row. The way I handled the edge cases was if an index is on the edge, if a number is on the edge, then it’s just going to get it’s upper side on the left and it’s upper right on the middle, then from right on the end. Otherwise, it’s just going to get the dp from the previous three. from the beginning of my code its going to fill up the input. Then, dp is going to be the minimum of  these 2 plus itself(for(int i=1;i<m;i++){for(int j=0;j<n; j++){ if(j==0)). Then for dp[i][j] = grid[i][j] +Math.min(dp[i-1][j],dp[i-1];[j+1]; that’s for the last case on grid, so this is going to be either 6 +2 or 6+3 which its going to be 8. Now when I came at this point all I had to do was have else{dp[i-1]=grid[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1],dp[i-1][j+1]); (Math.min is what does the three things plus itself). So its going to be 5+1 or 2+3, its going to be 6 though (There isn’t a Math.min which would of taken the 3, in theory it would of though). At the end everything is filled out so 7 is going to be 7+5 or 7+6, its going to be 12, 8 is going to be either 8+5 or 8+6 or 8+8, which it was 8+5. Then,  9+6 or 9+8 which it ends up as 15, then finally im going to return 12 because it’s the lowest number on the bottom row which is the output.
